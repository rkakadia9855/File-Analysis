Got a file: testcases.txt
thread number 139918265669376 added to arr
Got a file: readme.pdf


inspecting ./Asst0/testcases.txt
thread number 139918257276672 added to arr


inspecting ./Asst0/readme.pdf
Got a file: tokenizer.c
thread number 139918248883968 added to arr
Got a dir: smt


inspecting ./Asst0/tokenizer.c
thread number 139918240491264 added to arr
Got a dir: dmt
Handling: ./Asst0/smt
./Asst0/smt was added at 0
thread number 139918232098560 added to arr
Joining: 139918265669376
Handling: ./Asst0/dmt
./Asst0/dmt was added at 0
test case 1:
input: "today is a beautiful day"
expected output:
word: â€œtodayâ€
word: â€œisâ€
word: â€œaâ€
word: â€œbeautifulâ€
word: â€œdayâ€

test case 2:
input: "0x4356abdc 0777 [] "
expected output:
hexadecimal integer: "0x4356abdc"
octal integer: "0777"
left bracket: "["
right bracket: "]"

test case 3:
input: â€œarray[xyz ] += pi 3.14159e-10â€
expected output:
word: "array"
left bracket: "["
word: "xyz"
right bracket: "]"
plus equals: "+="
word: "pi"
float: "3.141519e-10"

test case 4:
input: "numbers 972 0x972 A8 0XA8 XA8 0972 072"
expected output:
word: "numbers"
decimal integer: "972"
hexadecimal integer: "0x972"
word: "A8"
hexadecimal integer: "0XA8"
word: "XA8"
decimal integer: "0972"
octal integer: "072"

test case 5:
input: "3.1 03.1 x3.1 0x3.1 30x1.x"
expected output:
floating point: "3.1"
floating point: "03.1"
word: "x3"
structure member: "."
decimal integer: "1"
hexadecimal integer: "0x3"
structure member: "."
decimal integer: "1"
decimal integer: "30"
word: "x1"
structure member: "x"
word: "x"

test case 6:
input: "+,++,+++,++++,+++++,++=,+++=="
expected output:
addition: "+"
comma: ","
increment: "++"
comma: ","
increment: "++"
addition: "+"
comma: ","
increment: "++"
increment: "++"
comma: ","
increment: "++"
increment: "++"
addition: "+"
comma: ","
increment: "++"
assignment: "="
comma: ","
increment: "++"
plus equals: "+="
assignment: "="

test case 7:
input: "arr12x0. da+-=*.32e- []"
expected output:
word: "arr"
decimal integer: "12"
word: "x0"
structure member: "."
word: "da"
addition: "+"
minus equals: "-="
multiplication: "*"
structure member: "."
decimal integer: "32"
word: "e"
minus: "-"
left bracket: "["
right bracker: "]"

test case 8:
input: "hello123 456world"
expected output:
word: "hello123"
decimal integer: "456"
word: "world"
q
%PDF-1.5
%
2 0 obj
<< /Linearized 1 /L 16460 /H [ 687 126 ] /O 6 /E 16185 /N 1 /T 16184 >>
endobj

3 0 obj
<< /Type /XRef /Length 50 /Filter /FlateDecode /DecodeParms << /Columns 4 /Predictor 12 >> /W [ 1 2 1 ] /Index [ 2 15 ] /Info 11 0 R /Root 4 0 R /Size 17 /Prev 16185                 /ID [<fd104b2c60852ceaf2410cc5ad4cb7c7><fd104b2c60852ceaf2410cc5ad4cb7c7>] >>
stream
xcbdg`b`8       $XF@D= nFl
handled: ./Asst0/smt
Joining: 139918257276672
Joining: 139918248883968
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<ctype.h>

/**
* This function is intended to check is a given string is an operator
* char *str: the string that needs to be checked
* char **opList: the list of operators
* returns 0 if the given string is an operator, -1 otherwise.
*/
int matchOperator(char *str, char **opList) {
    int i = 0; //variable to track loop
    for(i = 0; i < 42; i++) {
        if(strcmp(opList[i], str) == 0) {
            return 0;
        }
    }
    return -1;
}

/**
* This function is intended to get the index of a given operator in the operator list
* char *str: the operator whose index is to be found
* char **opList: the list of operators
* returns index of the operator if the index was found, -1 otherwise.
*/
int operatorIndex(char *str, char **opList) {
    int i = 0; //variable to track loop
    for(i = 0; i < 42; i++) {
        if(strcmp(opList[i], str) == 0) {
            return i;
        }
    }
    return -1;
}

/**
* This function forms a substring
* char *src: the original string
* int m: strating index of the substring
* int n: ending index of the susbtring (excluded)
* returns the substring that is formed
*/
char *getSubstring(const char *src, int m, int n) {
        int len = n - m; //length of the destination string
        char *dest = (char*)malloc(sizeof(char) * (len + 1));
        for (int i = m; i < n && (*(src + i) != '\0'); i++) {
                *dest = *(src + i);
                dest++;
        }
        *dest = '\0';
        return dest - len;
}

/**
* This function tokenizes the string passed using an operator as the delimeter
* char *str: the string that needs to be tokenized
* char *delim: the delimeter of the tokenizer
* char **opList: this list of operators
* int *numElement: number of tokens formed after tokenizing
* returns an array of strings that were tokenized
*/
char **tokenizer(char *str, char *delim, char **opList, int *numElem) {
    int i = 0;
    int j = 0;
    int operatorSize = sizeof(opList)/sizeof(opList[0]);
    char *operatorComparison = "(";
    int arrIndex = 0;
    char *decimalChar = ".";
    char *minusChar = "-";
    char **resultArr = (char **) malloc(sizeof(char *) * 1000);
    if(strcmp(delim, operatorComparison) == 0) {
        int firstIndex = 0;
        int decimalCount = 0;
        int minusCount = 0;
        for(i = 0; i < strlen(str); i++) {
            char *temp = getSubstring(str, i, i+1);
            char *temp2 = "temp";
            int match = -1;
            match = matchOperator(temp, opList);
            if(match == 0) {
                // check if the operator is . or -
                if((strcmp(temp, minusChar) == 0) && (minusCount != 0)) {
                    if(i != 0) {
                        temp2 = getSubstring(str, firstIndex, i);
                        char *emptyStr = "";
                        if(strcmp(temp2, emptyStr) != 0) {
                            resultArr[arrIndex] = temp2;
                            arrIndex++;
                            *numElem = *numElem + 1;
                        }
                    }
                    resultArr[arrIndex] = temp;
                    arrIndex++;
                    firstIndex = i + 1;
                    *numElem = *numElem + 1;
                    minusCount = 0;
                }
                else if((strcmp(temp, decimalChar) == 0) && (decimalCount != 0)) {
                    if(i != 0) {
                        temp2 = getSubstring(str, firstIndex, i);
                        char *emptyStr = "";
                        if(strcmp(temp2, emptyStr) != 0) {
                            resultArr[arrIndex] = temp2;
                            arrIndex++;
                            *numElem = *numElem + 1;
                        }
                    }
                    resultArr[arrIndex] = temp;
                    arrIndex++;
                    firstIndex = i + 1;
                    *numElem = *numElem + 1;
                    decimalCount = 0;
                }
                else if((strcmp(temp, decimalChar) == 0) && (decimalCount == 0) && (i != (strlen(str) - 1))) {
                    if(i == 0)
                        decimalCount++;
                    else if(isdigit(str[i - 1]))
                        decimalCount++;
                    else {
                        if(i != 0) {
                        temp2 = getSubstring(str, firstIndex, i);
                        char *emptyStr = "";
                        if(strcmp(temp2, emptyStr) != 0) {
                            resultArr[arrIndex] = temp2;
                            arrIndex++;
                            *numElem = *numElem + 1;
                        }
                    }
                        resultArr[arrIndex] = temp;
                        arrIndex++;
                        firstIndex = i + 1;
                        *numElem = *numElem + 1;
                    }
                }
                else if((strcmp(temp, minusChar) == 0) && (minusCount == 0) && (i != (strlen(str) - 1))) {
                    char *e = "e";
                    char *comp = getSubstring(str, i-1, i);
                    if((i != 0) && (i != 1) && (strcmp(e, comp) == 0 ))
                        minusCount++;
                    else {
                        if(i != 0) {
                        temp2 = getSubstring(str, firstIndex, i);
                        char *emptyStr = "";
                        if(strcmp(temp2, emptyStr) != 0) {
                            resultArr[arrIndex] = temp2;
                            arrIndex++;
                            *numElem = *numElem + 1;
                        }
                    }
                        resultArr[arrIndex] = temp;
                        arrIndex++;
                        firstIndex = i + 1;
                        *numElem = *numElem + 1;
                    }
                }
                else {
                    if(i != 0) {
                        temp2 = getSubstring(str, firstIndex, i);
                        char *emptyStr = "";
                        if(strcmp(temp2, emptyStr) != 0) {
                            resultArr[arrIndex] = temp2;
                            arrIndex++;
                            *numElem = *numElem + 1;
                        }
                    }
                    resultArr[arrIndex] = temp;
                    arrIndex++;
                    firstIndex = i + 1;
                    *numElem = *numElem + 1;
                }
            }
            else {
                if(i == (strlen(str) - 1)) {
                    temp2 = getSubstring(str, firstIndex, (i+1));
                    resultArr[arrIndex] = temp2;
                    *numElem = *numElem + 1;
                    arrIndex++;
                    firstIndex = i + 1;
                }
            }
        }
        return resultArr;
    }

    return resultArr;
}

/**
* This function tokenizes the number type string that was passed. It removes any alphabets except of x and e
* (so that hexadecimal and floating type are not excluded) and also removes any "extra" operators, i.e. decimals
* and - from floating types are not removed
* char *str: the string that needs to be tokenized
* char **opList: the operator list
* int *numElement: number of strings formed after tokenization
* returns an array of tokenized string
*/
char **numTokenizer(char *str, char **opList, int *numElem) {
    // if first char is digit, tokenizer if alpha found, and alpha is not x or e
    // if it has an x in it, remove any decimals
    int i = 0;
    int j = 0;
    int arrIndex = 0;
    char **resultArr = (char **) malloc(sizeof(char *) * 1000);
    int allowDecimal = 0;
    int decimalPresent = -1;
    int startingAlpha = -1;
    int firstIndex = 0;
    for(i = 0; i < strlen(str); i++) {
        char *temp = getSubstring(str, i, i+1);
        char *temp2 = "temp";
        int match = -1;
        if(isalpha(str[i])) {
            if((i == 1) && ((str[i] == 'x') || (str[i] == 'X')) && (str[i-1] == '0')) {
                // make sure there are no decimals
                allowDecimal = -1;
            }
            else if((str[i] == 'e') && (i != (strlen(str) - 1)) && (str[i+1] == '-') ) {
                //maybe continue
                continue;
            }
            else if(allowDecimal == -1) {
                if(isxdigit(str[i])) {
                    if(i != (strlen(str) - 1))
                        continue;
                    else {
                        temp2 = getSubstring(str, firstIndex, (i+1));
                        resultArr[arrIndex] = temp2;
                        *numElem = *numElem + 1;
                        arrIndex++;
                        firstIndex = i + 1;
                    }
                }
            }
            else {
                //carry out tokenization
                // remove alph
                temp2 = getSubstring(str, firstIndex, i);
                char *emptyStr = "";
                if(strcmp(temp2, emptyStr) != 0) {
                    resultArr[arrIndex] = temp2;
                    arrIndex++;
                    *numElem = *numElem + 1;
                }
                if((i != (strlen(str) - 1)) && isalnum(str[i+1])) {
                    firstIndex = i;
                }
                else {
                    resultArr[arrIndex] = temp;
                    arrIndex++;
                    firstIndex = i + 1;
                    *numElem = *numElem + 1;
                }
            }
        }
        else if((str[i] == '.') ) {
            if((allowDecimal == -1)) {
                temp2 = getSubstring(str, firstIndex, i);
                char *emptyStr = "";
                if(strcmp(temp2, emptyStr) != 0) {
                    resultArr[arrIndex] = temp2;
                    arrIndex++;
                    *numElem = *numElem + 1;
                }
                resultArr[arrIndex] = temp;
                arrIndex++;
                firstIndex = i + 1;
                *numElem = *numElem + 1;
            }
            else if((i != (strlen(str) - 1)) && (isalpha(str[i+1]))) {
                temp2 = getSubstring(str, firstIndex, i);
                char *emptyStr = "";
                if(strcmp(temp2, emptyStr) != 0) {
                    resultArr[arrIndex] = temp2;
                    arrIndex++;
                    *numElem = *numElem + 1;
                }
                resultArr[arrIndex] = temp;
                arrIndex++;
                firstIndex = i + 1;
                *numElem = *numElem + 1;
            }
        }
        else {
            //keep forming a substring
            if(i == (strlen(str) - 1)) {
                temp2 = getSubstring(str, firstIndex, (i+1));
                resultArr[arrIndex] = temp2;
                *numElem = *numElem + 1;
                arrIndex++;
                firstIndex = i + 1;
            }
        }
    }
    return resultArr;
}

/**
* This function tokenizes a word that is passed. i.e. it removes any operators if still present
* char *str: the string that needs to be tokenized
* char **opList: the operator list
* int *numElement: number of strings formed after tokenization
* returns an array of tokenized string
*/
char **wordTokenizer(char *str, char **opList, int *numElem) {
    int i = 0;
    int j = 0;
    int arrIndex = 0;
    char **resultArr = (char **) malloc(sizeof(char *) * 1000);
    int firstIndex = 0;
    for(i = 0; i < strlen(str); i++) {
        char *temp = getSubstring(str, i, i+1);
        char *temp2 = "temp";
        int match = -1;
        match = matchOperator(temp, opList);
        if(match == 0) {
            if(i != 0) {
                temp2 = getSubstring(str, firstIndex, i);
                char *emptyStr = "";
                if(strcmp(temp2, emptyStr) != 0) {
                    resultArr[arrIndex] = temp2;
                    arrIndex++;
                    *numElem = *numElem + 1;
                }
            }
            resultArr[arrIndex] = temp;
            arrIndex++;
            firstIndex = i + 1;
            *numElem = *numElem + 1;
        }
        else {
            if(i == (strlen(str) - 1)) {
                temp2 = getSubstring(str, firstIndex, (i+1));
                resultArr[arrIndex] = temp2;
                *numElem = *numElem + 1;
                arrIndex++;
                firstIndex = i + 1;
            }
        }
    }
    return resultArr;
}

/**
* this function separates/tokenizes all the strings, that were first tokenized using white spaces only
* char **firstArr: an array of strings that were tokenized using white spaces
* char **secondArr: an array of strings that will store the tokenized string
* int firstArrLen: length of firstArr
* int *secondArrLen: pointer to the length of secondArr
* char **opList: the operator list
*/
void furtherSeparation(char **firstArr, char **secondArr, int firstArrLen, int *secondArrLen, char **opList) {
    int i = 0;
    int j = 0;
    int trackArr = 0; //tracker for secondArr
    int numTemp = 0; //tracker for temp array
    char **temp = (char **) malloc(sizeof(char *) * (firstArrLen+100)); // replaces the first array
    for(i = 0; i < firstArrLen; i++) {
        char *op = "(";
        int numBroken = 0;
        char **temporary = tokenizer(firstArr[i], op, opList, &numBroken);
        for(j = 0; j < numBroken; j++) {
            temp[numTemp] = temporary[j];
            numTemp++;
        }
    }
    for(i = 0; i < numTemp; i++) {
        // if first char is alpha, remove any operators if left
        if(isalpha(temp[i][0])) {
            // separate the token and then add those to array
            int countSeparations = 0;
            int k = 0;
            char **temporary = wordTokenizer(temp[i], opList, &countSeparations);
            for(k = 0; k < countSeparations; k++) {
                secondArr[trackArr] = temporary[k];
                *secondArrLen = *secondArrLen + 1;
                trackArr++;
            }
        }
        // if first char is digit, tokenizer if alpha found, and alpha is not x or e
        // if it has an x in it, remove any decimals
        else if(isdigit(temp[i][0])) {
            // separate the token and then add those to array
            int countSeparations = 0;
            int k = 0;
            char **temporary = numTokenizer(temp[i], opList, &countSeparations);
            for(k = 0; k < countSeparations; k++) {
                secondArr[trackArr] = temporary[k];
                *secondArrLen = *secondArrLen + 1;
                trackArr++;
            }
        }
        else {
            secondArr[trackArr] = temp[i];
            *secondArrLen = *secondArrLen + 1;
                trackArr++;
        }
    }

}

/**
* This function checks if the given string is a hexadecimal integer
* char *str: the string that needs to be checked
* returns 0 if the str is hexadecimal, -1 otherwise
*/
int isHexa(char *str) {
    int i = 0;
    int loop = strlen(str);
    int containsX = -1;
    if(str[0] != '0')
        return -1;
    for(i = 0; i < loop; i++) {
        if(str[i] == 'x' || str[i] == 'X')
            containsX = 0;
        else if(!(isxdigit(str[i]))) {
            return -1;
        }
    }
    return containsX;
}

/**
* This function checks if the given string is octal
* char *str: the string that needs to be checked
* returns 0 if the str is octal, -1 otherwise
*/
int isOct(char *str) {
    int i = 0;
    int loop = strlen(str);
    for(i = 0; i < loop; i++) {
        if((i == 0) && (str[i] != '0'))
            return -1;
        if((str[i] > '7') || (str[i] < '0')) {
            return -1;
        }
    }
    return 0;
}

/**
* This function checks if the given string is floating type
* char *str: the string that needs to be checked
* returns 0 if the str is floating type, -1 otherwise
*/
int isFloating(char *str) {
    int i = 0;
    int loop = strlen(str);
    for(i = 0; i < loop; i++) {
        if(str[i] == '.')
            return 0;
        else if(str[i] == 'e')
            return 0;
    }
    return -1;
}


int main(int argc, char **argv)
{
    if(argc != 2) {
        printf("%s\n", "Invalid number of arguments.");
        return -1;
    }

    char *initialString = argv[1];
    int initialLength  = 0;
    initialLength = strlen(initialString);
    int i = 0;
    int trackOutputArr = 0;
    int insideTracker = 0;

    char *operatorList[] = {"(", ")", "[", "]", ".", "->", "sizeof", ",", "!", "~", ">>", "<<",
     "^", "|", "++", "--", "+", "/", "||", "&&", "?", ":", "==", "!=", "<", ">", "<=", ">=", "=",
     "+=", "-=", "*=", "/=", "%=", ">>=", "<<=", "&=", "^=", "|=", "&", "-", "*"};

     char *operatorName[] = {"left parenthesis", "right parenthesis", "left bracket", "right bracket",
     "structure member", "structure pointer", "sizeof", "comma", "negate", "1s complement", "shift right",
     "shift left", "bitwise XOR", "bitwise OR", "increment", "decrement", "addition", "division", "logical OR",
     "logical AND", "conditional true", "conditional false", "equality test", "inequality test", "less than test",
     "greater than test", "less than or equal test", "greater than or equal test", "assignment", "plus equals",
     "minus equals", "times equals", "divide equals", "mod equals", "shift right equals", "shift left equals",
     "bitwise AND equals", "bitwise XOR equals", "bitwise OR equals", "AND/address operator",
     "minus/subtract operator", "multiply/dereference operator"};

    // build a 2-d output array and allocate space for all arrays in this array
    char **outputArr = (char **) malloc(sizeof(char *) * initialLength);
    for(i = 0; i < initialLength; i++) {
        outputArr[i] = (char *) malloc(sizeof(char) * initialLength);
    }

    // first tokenize string by separating white-spaces
    for(i = 0; i < initialLength; i++) {
        if(!(isspace(initialString[i])) && !(initialString[i] == '\0') && (i != (initialLength - 1))) {
                outputArr[trackOutputArr][insideTracker] = initialString[i];
                insideTracker++;
        }
        else {
            if(trackOutputArr < initialLength) {
                if((i == (initialLength - 1)) && !(isspace(initialString[i])) ) {
                        outputArr[trackOutputArr][insideTracker] = initialString[i];
                        insideTracker++;

                }
                outputArr[trackOutputArr] = strcat(outputArr[trackOutputArr], "\0");
                trackOutputArr++;
                insideTracker = 0;
            }
            else {
                printf("%s\n", "Some error occured. output array exceeded initialLength of the string");
            }
        }
    }

    // send all tokens for second round of separations. i.e. separate strings from operators
    int finalOutputTracker = 0;
    char **tempOutputArr = (char **) malloc(sizeof(char *) * initialLength);
    for(i = 0; i < initialLength; i++) {
        tempOutputArr[i] = (char *) malloc(sizeof(char) * initialLength);
    }

    furtherSeparation(outputArr, tempOutputArr, trackOutputArr, &finalOutputTracker, operatorList);

    // time to combine operators that need to be combined. eg: if arr[0] is + and arr[1] is +, they can be
    // combined into arr[0]: ++
    // loop through each var not each character
    char **draftOutputArr = (char **) malloc(sizeof(char *) * initialLength);
    for(i = 0; i < finalOutputTracker; i++) {
        draftOutputArr[i] = (char *) malloc(sizeof(char) * initialLength);
    }
    int draftOutputTracker = 0;
    for(i = 0; i < finalOutputTracker; i++) {
        if(matchOperator(tempOutputArr[i], operatorList) == 0) {
            // if > or <, check for >>> <<< (if not), check for >> <<
            //else check other operators
            if((strcmp(tempOutputArr[i], ">") == 0) || strcmp(tempOutputArr[i], "<") == 0) {
                if( (i != (finalOutputTracker - 1)) && (strcmp(tempOutputArr[i], tempOutputArr[i+1]) == 0)) {
                    if( (i != (finalOutputTracker - 2)) && (strcmp("=", tempOutputArr[i+2]) == 0)) {
                        char temp001[100]; //temp variable
                        strcpy(temp001, tempOutputArr[i]);
                        strcat(temp001, tempOutputArr[i+1]);
                        strcat(temp001, tempOutputArr[i+2]);
                        strcpy(draftOutputArr[draftOutputTracker], temp001);
                        draftOutputTracker++;
                        i = i + 2;
                    }
                    else {
                        char temp002[100]; //temp variable
                        strcpy(temp002, tempOutputArr[i]);
                        strcat(temp002, tempOutputArr[i+1]);
                        strcpy(draftOutputArr[draftOutputTracker], temp002);
                        draftOutputTracker++;
                        i = i + 1;
                    }
                }
                else if((i != (finalOutputTracker - 1))) {
                    char temp003[100]; //temp variable
                    strcpy(temp003, tempOutputArr[i]);
                    strcat(temp003, tempOutputArr[i+1]);
                    if(matchOperator(temp003, operatorList) == 0) {
                        strcpy(draftOutputArr[draftOutputTracker], temp003);
                        draftOutputTracker++;
                        i = i + 1;
                    }
                    else {
                        draftOutputArr[draftOutputTracker] = tempOutputArr[i];
                        draftOutputTracker++;
                    }
                }
                else {
                    draftOutputArr[draftOutputTracker] = tempOutputArr[i];
                    draftOutputTracker++;
                }
            }
            else {
                char temp004[100]; //temp variable
                strcpy(temp004, tempOutputArr[i]);
                if(i != (finalOutputTracker - 1)) {
                    strcat(temp004, tempOutputArr[i+1]);
                    if(matchOperator(temp004, operatorList) == 0) {
                        strcpy(draftOutputArr[draftOutputTracker], temp004);
                        draftOutputTracker++;
                        i = i + 1;
                    }
                    else {
                        draftOutputArr[draftOutputTracker] = tempOutputArr[i];
                        draftOutputTracker++;
                    }
                }
                else {
                    strcpy(draftOutputArr[draftOutputTracker], temp004);
                    draftOutputTracker++;
                }
            }
        }
        else {
            draftOutputArr[draftOutputTracker] = tempOutputArr[i];
            draftOutputTracker++;
        }
    }

    char **resultantOutputArr = (char **) malloc(sizeof(char *) * draftOutputTracker);
    for(i = 0; i < initialLength; i++) {
        resultantOutputArr[i] = (char *) malloc(sizeof(char) * initialLength);
    }
    // time to add their types to the tokens
    for(i = 0; i < draftOutputTracker; i++) {
        if(strcmp(draftOutputArr[i], "sizeof") == 0) {
            strcpy(resultantOutputArr[i], "sizeof: \"");
            strcat(resultantOutputArr[i], draftOutputArr[i]);
            strcat(resultantOutputArr[i], "\"");
        }
        else if(isalpha(draftOutputArr[i][0])) {
            strcpy(resultantOutputArr[i], "word: \"");
            strcat(resultantOutputArr[i], draftOutputArr[i]);
            strcat(resultantOutputArr[i], "\"");
        }
        else if(!(isalnum(draftOutputArr[i][0]))) {
            int indexFound = 0;
            indexFound = operatorIndex(draftOutputArr[i], operatorList);
            if(indexFound != -1) {
                strcpy(resultantOutputArr[i], operatorName[indexFound]);
                strcat(resultantOutputArr[i], ": \"");
                strcat(resultantOutputArr[i], draftOutputArr[i]);
                strcat(resultantOutputArr[i], "\"");
            }
        }
        else if(isdigit(draftOutputArr[i][0])) {
            if(isHexa(draftOutputArr[i]) == 0) {
                strcpy(resultantOutputArr[i], "hexadecimal integer: \'");
                strcat(resultantOutputArr[i], draftOutputArr[i]);
                strcat(resultantOutputArr[i], "\"");
            }
            else if(isOct(draftOutputArr[i]) == 0) {
                strcpy(resultantOutputArr[i], "octal integer: \'");
                strcat(resultantOutputArr[i], draftOutputArr[i]);
                strcat(resultantOutputArr[i], "\"");
            }
            else if(isFloating(draftOutputArr[i]) == 0) {
                strcpy(resultantOutputArr[i], "floating point: \'");
                strcat(resultantOutputArr[i], draftOutputArr[i]);
                strcat(resultantOutputArr[i], "\"");
            }
            else {
                strcpy(resultantOutputArr[i], "decimal integer: \'");
                strcat(resultantOutputArr[i], draftOutputArr[i]);
                strcat(resultantOutputArr[i], "\"");
            }
        }
    }

    for(i = 0; i < draftOutputTracker; i++) {
        printf("%s\n", resultantOutputArr[i]);
    }
    free(resultantOutputArr);

    for(i = 0; i < draftOutputTracker; i++) {
            free(draftOutputArr[i]);
    }
    free(draftOutputArr);
    for(i = 0; i < finalOutputTracker; i++) {
        free(tempOutputArr[i]);
    }
    free(tempOutputArr);

    for(i = 0; i < trackOutputArr; i++) {
        free(outputArr[i]);
    }
    free(outputArr);

    return 0;
}

thread number 139917887796992 added to arr
Joining: 139918240491264
Joining: 139918232098560


inspecting ./Asst0/dmt/smt.txt


inspecting ./Asst0/dmt/hello.txt
thread number 139918257276672 added to arr
thread number 139918240491264 added to arr


inspecting ./Asst0/dmt/world.txt
handled: ./Asst0/dmt
Joining: 139917887796992

Joining: 139918257276672

Joining: 139918240491264

Threads: 7
Directories: 1
Files: 5
File name: ./Asst0/testcases.txt
Next file: ./Asst0/readme.pdf
File name: ./Asst0/readme.pdf
Next file: ./Asst0/tokenizer.c
File name: ./Asst0/tokenizer.c
Next file: ./Asst0/dmt/smt.txt
File name: ./Asst0/dmt/smt.txt
Next file: ./Asst0/dmt/hello.txt
File name: ./Asst0/dmt/hello.txt
Next file: ./Asst0/dmt/world.txt
File name: ./Asst0/dmt/world.txt